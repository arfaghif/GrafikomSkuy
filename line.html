<!doctype html>
<html>
   <body>
      <canvas width = "570" height = "570" id = "my_Canvas"></canvas>

      <button onclick="changeLineLength()"> + 1 length</button>
      <script>
         /*============ Creating a canvas =================*/
      
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
      
         /*========== Defining and storing the geometry =========*/

         // import vertices from "./vertices.js";
         var vertices = [
            -0.5,0.5,0.0,
            0.0,0.4,0.0,
         ];

         indices = [0,1];

         drawing();

         // buat debug
         // var dist = distance(vertices[0], vertices[1], vertices[3], vertices[4]);
         // console.log(dist);

         function createVertexBuffer() {
            // Create an empty buffer object to store vertex buffer
            var vertex_buffer = gl.createBuffer();
   
            // Bind appropriate array buffer to it
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
   
            // Pass the vertex data to the buffer
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
   
            // Unbind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            return vertex_buffer;

         }
         function createIndexBuffer() {
            // Create an empty buffer object to store Index buffer
            var Index_Buffer = gl.createBuffer();
   
            // Bind appropriate array buffer to it
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
   
            // Pass the vertex data to the buffer
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
   
            // Unbind the buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            return Index_Buffer;
         }


         /*====================== Shaders =======================*/

         function vertexShader() {
            // Vertex shader source code
            var vertCode =
               'attribute vec3 coordinates;' +
               'void main(void) {' +
                  ' gl_Position = vec4(coordinates, 1.0);' +
               '}';
   
            // Create a vertex shader object
            var vertShader = gl.createShader(gl.VERTEX_SHADER);
   
            // Attach vertex shader source code
            gl.shaderSource(vertShader, vertCode);
   
            // Compile the vertex shader
            gl.compileShader(vertShader);   
            
            return vertShader;
         }

         function fragmentShader() {
            // Fragment shader source code
            var fragCode =
               'void main(void) {' +
                  ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
               '}';
   
            // Create fragment shader object 
            var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
   
            // Attach fragment shader source code
            gl.shaderSource(fragShader, fragCode);
   
            // Compile the fragmentt shader
            gl.compileShader(fragShader);

            return fragShader;
         }

         function shaderProgram() {
            // Create a shader program object to
            // store the combined shader program
            var shaderProgram = gl.createProgram();
   
            // Attach a vertex shader
            gl.attachShader(shaderProgram, vertexShader());
   
            // Attach a fragment shader
            gl.attachShader(shaderProgram, fragmentShader());
   
            // Link both the programs
            gl.linkProgram(shaderProgram);
   
            // Use the combined shader program object
            gl.useProgram(shaderProgram);

            return shaderProgram;
         }

         function associateBuffer() {
            /* ======= Associating shaders to buffer objects =======*/
   
            // Bind vertex buffer object
            gl.bindBuffer(gl.ARRAY_BUFFER, createVertexBuffer());
   
            // Bind index buffer object
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, createIndexBuffer()); 
   
            // Get the attribute location
            var coord = gl.getAttribLocation(shaderProgram(), "coordinates");
   
            // Point an attribute to the currently bound VBO
            gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
   
            // Enable the attribute
            gl.enableVertexAttribArray(coord);

         }

         function drawing() {
            associateBuffer();
            /*============= Drawing the Quad ================*/
   
            // Clear the canvas
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
   
            // Enable the depth test
            gl.enable(gl.DEPTH_TEST);
   
            // Clear the color buffer bit
            gl.clear(gl.COLOR_BUFFER_BIT);
   
            // Set the view port
            gl.viewport(0,0,canvas.width,canvas.height);
   
            // Draw the triangle
            gl.drawElements(gl.LINES, indices.length, gl.UNSIGNED_SHORT,0);
         }

         function changeLineLength() {
            var x1 = vertices[0];
            var y1 = vertices[1];
            var x2 = vertices[3];
            var y2 = vertices[4];


            var dist = roundToTwoDecimals(distance(x1,y1,x2,y2));
            dist = dist + 0.1;
            var m = (y2 - y1) / (x2 - x1);

            var incr_x = 0.1;
            var incr_y = 0.1;

            if (x2 < x1) {
               incr_x *= -1;
            }

            if (y2 < y1) {
               incr_y *= -1;
            }
            
            var newPoint = []

            if (y1==y2) {
               if (x1==x2) {
                  newPoint.push(x1 + incr_x);
                  newPoint.push(y1 + incr_y);
               }
               else {
                  newPoint.push(x2 + incr_x);
                  newPoint.push(y2);
               }
            }
            else if (x1==x2) {
               newPoint.push(x1);
               newPoint.push(y2 + incr_y);
            }
            else {
            for (var i=(x2 - 0.1); i < x2 + 0.1; i=i+0.001){

                  var y = ((i - x1) * (y2 - y1) / (x2 - x1)) + y1;
                  // console.log("x = "+i);
                  // console.log("y = " +y);
                  let newDist = roundToTwoDecimals(distance(x1,y1,i,y));
                  if (newDist == dist) {
                     newPoint.push(i);
                     newPoint.push(y);
                     break;
                  }
               }
            }
            vertices[3] = newPoint[0];
            vertices[4] = newPoint[1];
            drawing();
         }

         function distance(x1,y1,x2,y2) {
            return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5;
         }

         function roundToTwoDecimals(number) {
            return Math.round((number + Number.EPSILON) * 100) /100
         }
      </script>
   </body>
</html>
